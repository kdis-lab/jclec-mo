package net.sf.jclec;

import java.util.List;
import java.util.ArrayList;
import java.util.Comparator;

import net.sf.jclec.binarray.BinArrayIndividual;
import net.sf.jclec.binarray.BinArrayIndividualSpecies;

import net.sf.jclec.fitness.SimpleValueFitness;
import net.sf.jclec.fitness.ValueFitnessComparator;

import net.sf.jclec.util.random.DummyRandGenFactory;

/**
 * Selector tests.
 * 
 * @author Sebastian Ventura
 *
 * @param <S> Type of selector to test
 */

public abstract class ISelectorTest<S extends ISelector> extends IToolTest<S> 
{
	/////////////////////////////////////////////////////////////////
	// --------------------------------------------------- Attributes
	/////////////////////////////////////////////////////////////////
	
	/** Individual recombined in testRecombine() */
	
	protected List<IIndividual> source;

	/** Individual expected in testRecombine() */

	protected List<IIndividual> expected;
	
	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Constructors
	/////////////////////////////////////////////////////////////////

	/**
	 * Default constructor
	 */
	
	public ISelectorTest(Class<S> toolClass, String testName) 
	{
		super(toolClass, testName);
	}

	/////////////////////////////////////////////////////////////////
	// -------------------------------- Overwriting IToolTest methods
	/////////////////////////////////////////////////////////////////

	@Override
	protected void setUp() throws Exception 
	{
		// Call super method
		super.setUp();
		// Create parents
		createSource();
		// Create expected
		createExpected();
	}

	/////////////////////////////////////////////////////////////////
	// ------------------------------------------------- Unitary test
	/////////////////////////////////////////////////////////////////

	/**
	 * Unit test for select() method.   
	 */
	
	public void testSelect()
	{
		// Mutate parents
		List<IIndividual> result = tool.select(source, 1);
		// Assert result and expected have the same size
		assertEquals(expected.size(), result.size());
		// Assert result individuals are expected
		int es = expected.size();
		for (int i=0; i<es; i++) {
			assertEquals(expected.get(i), result.get(i));
		}
	}
	
	/////////////////////////////////////////////////////////////////
	// -------------------------------------------- Protected methods
	/////////////////////////////////////////////////////////////////
	
	protected ISystem createContext()
	{
		// System that act as context
		Population pop = new Population ();
		// Random generators factory
		DummyRandGenFactory randGenFactory = new DummyRandGenFactory();
		randGenFactory.setDummySequence(new double [] {0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9});
		pop.setRandGenFactory(randGenFactory);
		// System species
		pop.setSpecies(new BinArrayIndividualSpecies(new byte[] {1, -1, -1, -1}));
		// System evaluator
		pop.setEvaluator
			(
				new IEvaluator () 
				{
					/** Generated by Eclipse */
					
					private static final long serialVersionUID = -3469432539611803519L;
					
					final ValueFitnessComparator comparator = new ValueFitnessComparator();
					
					public void evaluate(List<IIndividual> inds) 
					{
						// Do nothing
					}

					public int getNumberOfEvaluations() 
					{
						return 0;
					}

					public Comparator<IFitness> getComparator() 
					{
						return comparator;
					}
				}
			);
		// Return pop 
		return pop;
	}
	
	/** Create source set */
	
	protected void createSource()
	{
		source = new ArrayList<IIndividual> ();
		source.add(new BinArrayIndividual(new byte [] {1, 0, 0, 1}, new SimpleValueFitness(0.25)));
		source.add(new BinArrayIndividual(new byte [] {1, 1, 0, 1}, new SimpleValueFitness(0.52)));
		source.add(new BinArrayIndividual(new byte [] {1, 0, 1, 1}, new SimpleValueFitness(0.15)));
		source.add(new BinArrayIndividual(new byte [] {1, 1, 1, 1}, new SimpleValueFitness(0.35)));
		source.add(new BinArrayIndividual(new byte [] {0, 0, 0, 1}, new SimpleValueFitness(0.95)));
		source.add(new BinArrayIndividual(new byte [] {0, 1, 0, 1}, new SimpleValueFitness(0.75)));
		source.add(new BinArrayIndividual(new byte [] {1, 0, 0, 1}, new SimpleValueFitness(0.65)));
		source.add(new BinArrayIndividual(new byte [] {1, 0, 0, 0}, new SimpleValueFitness(0.05)));
		source.add(new BinArrayIndividual(new byte [] {1, 1, 1, 1}, new SimpleValueFitness(0.25)));
		source.add(new BinArrayIndividual(new byte [] {0, 0, 0, 0}, new SimpleValueFitness(0.45)));
	}

	/** Create expected */
	
	protected abstract void createExpected();
}
